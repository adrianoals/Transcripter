E agora, pessoal, a gente chegou nesse último camarada, que é o nosso orquestrador. E somente para deixar muito claro aqui para vocês, essas são sessões sugeridas que eu recomendo para agentes desse tipo. Isso não significa que você não consegue fazer a mesma coisa aqui com essa estrutura ou, eventualmente, com essa. É tudo a forma de como você quer trabalhar. Essas estruturas vão te ajudar a não partir do zero e são recomendações, beleza? Então, por conta disso, eu quero trazer agora aqui esse Role Specification, onde a gente deixa claro esses aspectos aqui de definições, responsabilidades, framework operacional, decision making e communication standards, tá? Então, vamos lá, galera. Vamos falar do nosso orquestrador. Então, basicamente, eu estou criando um papel, como sempre a gente acaba fazendo isso, dizendo quem ele é. Então, nesse caso, eu estou falando que ele é um agente orquestrador de tarefas que vai ajudar a coordenar um ambiente onde o Cloud Code, nesse caso, que é o Mastercard, vai conseguir controlar agentes e fazendo a chamada desses agentes de forma paralela. Então, a ideia aqui é que esse agente consiga garantir a estrutura, caminhos e a auditabilidade desse multi-agente work ou seja, a ideia desse nosso orquestrador é ele garantir a fonte única da verdade para esse nosso manifesto.md que ele vai criar para garantir que tudo que for gerado do nosso projeto seja traqueado ali para daí nós termos certeza de todo o material que foi feito durante à execução, para daí então aquele comando gerar o nosso índex com todos os relatórios gerados, tá? Então, responsabilidade core dele, perceba aqui que eu não estou colocando necessariamente o que ele tem que fazer, tá? Mas sim o senso do que são pontos inegociáveis desse camarada. É um pouco diferente de objetivo, porque o objetivo ele dá uma visão mais a curto prazo, vamos dizer assim, do que vai ser feito. Aqui, na especificação e no papel, a gente já deixa uma ideia do que vai ser feito pelo escopo, mas a gente traz algumas responsabilidades que são importantes aqui para ele. Nesse caso é inicializar a estrutura do projeto criando um arquivo de manifesto. registrar todo o output das tarefas que foram completadas, e eu dei aqui usando o barra na frente, que vai ser utilizado como nome do relatório, com o agente que vai produzir. Garanta que essas políticas e normalizações vão ser baseadas nos argumentos que vão ser passados, e que a gente manda lá nos comandos. Garantir que cada componente possa ser comparável com a lista de componentes que vão ser gerados no nosso relatório de arquitetura para garantir que estão todo mundo registrado lá bonitinho para quando todo o trabalho terminar, ele conseguir sumarizar e a gente ter todos os relatórios que a gente precisa. E também a ideia é que como esse cara mantém o tracking de tudo que está sendo registrado, ele vai ajudar a prevenir, validando se há duplicações ou não nesses camaradas. E, no final das contas, também ele vai ter que validar e finalizar o manifesto.md. Então, se você perceber, pessoal, eu consigo, se eu fizer uma força não tão grande, portar essa estrutura para algo desse tipo ou para algo desse tipo por esse camarada aqui ele n tem uma complexidade t grande que a gente precisa tanta coisa nele Então, eu consigo deixar ele um pouco mais leve para não ser, inclusive, um prompt tão grande. E lembrando, quanto maior o prompt, maior a ambiguidade, maior a chance das coisas darem errado. Então, o nosso prompt tem que ser o mais assertivo possível. outro ponto agora que é o framework operacional ou seja, o workflow que ele vai trabalhar então, pontos importantes ponto da verdade aqui vai estar o caminho do manifesto e tudo que vai ser armazenado vai ser aqui por outros agentes vão estar registrados aqui somente o orquestrador escreve no manifesto.md como é que vai ser gerado os arquivos? a partir de onde? de qual parte? isso aqui vai ser gerado então isso aqui pra gente é um ponto super importante. Outra coisa importante é, não invente nome de pasta, não crie reports, outputs. Então, a gente está aqui no final das contas garantindo que esse nosso orquestrador, ele só vai trabalhar com manifesto.md e garantir que tudo que está sendo feito pelos outros agentes, ele vai estar fazendo double checking para garantir que quando todo o trabalho terminar, ele vai poder sintetizar tudo para daí a gente ter o resultado final. Registration Workflow. Quando o Master Coordinator, que é, no caso, o nosso Cloud, completar um artefato, grave imediatamente isso no manifesto.md, com o título, com o caminho absoluto, o nome do agente e o timestamp. Antes de gravar isso, verifique se o caminho existe. Componente Average Control. Estou falando, leia o diretório de arquitetura, o reporte de arquitetura, para garantir que todos os componentes fiquem lá no manifesto.md. Importante, grave no manifesto.md de uma forma que eu posso conseguir fazer o tracking de tarefas que estão pendentes para cada componente. Se qualquer componente faltar algum relatório e você verificar esse gap, passe isso para o seu coordenador, que é o Cloud, para que daí ele vá, provavelmente, chamar outros agentes para terminar aquele relatório. E aqui, a parte de finalizar a integridade. Então, confirme que todas as sessões estão no manifesto.md, valide cada caminho registrado, remova as duplicações. Então, isso aqui são pontos inegociáveis que é como ele vai trabalhar. E aqui eu tenho um decision-making principles. É uma forma de eu remover ambiguidade também. Então, por exemplo, separation of concerns. The master coordinator decides qual agente deve rodar e quando. O orquestrador apenas enforça a estrutura, a cobertura e o registro. Parallel safe recording. Registrar os outputs S1 o quanto antes para evitar problemas de race conditions. Ou seja, porque eu posso ter vários agentes modificando o mesmo arquivo ao mesmo tempo. Então, esse aí é um problema que pode acontecer e a gente não está isento. Isso aqui não é um banco de dados que a gente tem isolamento, mas, de forma geral, eu já percebi que, por exemplo, no comportamento do Cloud, ele percebe quando tem arquivos abertos, ele acaba mudando através de uma diferença ali. Ele faz um diff para não ter aquele tipo de problema. Então, eu não tive problema de race condition em relação a isso. State mínimo necessário ou seja, mantenha as notas operacionais mínimas e factuais para não ter que ficar fazendo recomendação sumarização, nada disso ou seja, trabalhe com o menos dado possível trabalhe com caminhos determinísticos para garantir certamente onde vai estar os nossos relatórios Safety over convenience então evite, ele não ele vai refutar, ele não vai registrar qualquer item de um caminho ou qualquer coisa duplicada que ele possa verificar Ent ele tem que verificar Ent a grande sacada aqui que eu vou trazer para ele conceitos que fazem com que eu tenha mais segurança na hora que esse orquestrador vai rodar. Tudo isso vai funcionar da melhor forma possível? Vai depender muito do modelo que você vai utilizar, vai depender muito do projeto que estiver rodando. com todos os testes que eu fiz aqui, eu tive ótimos resultados, mas isso não significa que sempre você vai ter o melhor resultado do mundo. Por isso que Prompt é algo evolutivo a cada momento, principalmente quando lançam modelos novos aí de A. E aqui, Communication Standards. Por que isso aqui é importante? Porque o nosso orquestrador vai falar com o coordenador, então a gente tem que garantir algumas coisas. Ou seja, nunca se comunique diretamente com o agente especialista. sempre traga de forma clara e estruturada as atualizações quando foi perguntar um status retorna uma lista de reports com o arquivo, com o título absoluto com o nome do agente com o timestamp e a checklist com os componentes que estão faltando aqui instrução e formato para o master coordinator a gente tem que lembrar que o nosso orquestrador ele vai falar diretamente com o cloud code Então, eu estou querendo aqui gerar para ele uma forma de fazer com que esse orquestrador se comunique de uma forma muito clara para esse cara, porque o Cloud Code aqui é ele que vai executar as outras tarefas e chamar outros agentes. Então, eu estou querendo fazer com que essa comunicação seja muito bem feita. Então, a instrução e o formato ali para o coordenador master. Então, especifique o diretório de saída para o especialista, seguindo o mesmo padrão, ignore qualquer coisa que não seja respeitada. Lembre-se sempre que quando um especialista finalizar, o resultado tem que ser retornado para o orquestrador para registrar. E aqui, manifeste disciplina. Somente o orquestrador edita e manter o manifesto limitado a traquear reports com o mínimo workflow, notas e coisas desse tipo. E ações proibidas. Ele não vai poder gerar vários agentes, ele não vai gerar sequências de agentes ou vai fazer prescrições de mudanças de código. Ele não vai criar sumário executivo, recomendações, vulnerabilidades, ali no manifest.md. Ele não vai estimar horas, não vai trabalhar com linguagens vagas e vai trabalhar da forma mais segura possível. Por que eu estou colocando isso? Porque esse tipo de comunicação, apesar de muitas dessas coisas estarem em outros prompts, aqui eu estou reforçando do que vai ser o comportamento do agente orquestrador. Então, se você perceber, é um template, é um prompt muito mais simples, porque ele traz basicamente a responsabilidade, como ele vai trabalhar, que é uma forma simples de manter o tracking de algo, e alguns princípios para tomar decisão em algum momento. Ou seja, separar as responsabilidades, trabalhar de uma forma segura quando for trabalhar de forma paralela, gravar e sempre mandar as informações com o mínimo possível, trabalhar com os caminhos determinísticos e também não registrar qualquer coisa que viole o que já foi combinado. E as nossas comunicações são importantes porque é como ele fala com o Cloud Code ali de forma geral. Então essas instruções para o Cloud Code são importantes porque aí eles mantêm, eles criam uma espécie de um protocolo de comunicação. É em linguagem natural, vamos dizer assim, mas ainda assim a gente garante que o Cloud Code está recebendo respostas e o orquestrador tamb est recebendo informa de uma forma mais precisa baseado nesses standards a que voc pode ir aprimorando o tempo todo E aqui eu coloquei um template de como vai ser o manifesto ou seja, o nome do projeto, o gerador, o caminho do orquestrador. Aí eu coloquei os reports, os componentes, por exemplo, e o workflow, o tasks, ideas, timestamp para cada report colocado, se já foi completado, se está pendente, se falhou, e anota as mínimas ali do que acontece. Então, com esse tipo de comportamento, a gente já vai conseguir, no final das contas, ter esse arquivo de manifesto, que na realidade é um arquivo apenas para a gente saber de onde a gente parou. É o arquivo que mantém o estado do nosso workflow em geral, quando eu tenho muitos agentes rodando. Eu poderia ser mais específico, inclusive nos comandos, sendo mais enfático que dentro das regras, terminou um agente, inicia um novo orquestrador para ele somente registrar. E você pode fazer isso e o Cloud vai criar um orquestrador para cada vez que uma tarefa for concluída. porém, o que eu percebi ao longo do tempo é que o resultado demora mais porque ele vai ter que subir o novo orquestrador dar baixa no arquivo e etc, então isso acaba demorando um pouco mais, por outro lado eu tenho o tracking mais em tempo real então da forma como está aqui, na maioria das vezes ele vai fazer aqui para mim o tracking dos dois relatórios primeiros, aí ele vai terminar a fase 3 ali, fazendo o relatório de cada componente e vai mudar o manifesto quando ele terminar todos. O grande problema de estado aí é que se a gente encerrar a sessão no meio desse processo e o orquestrador não tenha anotado, a gente vai ter que refazer esse processo como um todo. Então, é um trade-off no final das contas. Para cada tarefa gera um orquestrador para ele guardar, vai demorar um pouco mais, mas eu mantenho o tracking ou ele mantém o tracking quando ele terminar todos aqueles trabalhos em paralelo, vai depender de como você quer, da forma como está aqui, ele vai esperar todos aqueles em paralelo terminar para ele sair registrando, mas vai depender muito do seu comportamento, do tamanho da tarefa, do tempo do projeto o que eu quero sempre deixar claro galera, é que prompt é algo infinito, é algo que você testa, gasta muito tempo, gasta muito token para fazer isso no final das contas, mas é um trabalho que quando você vê tudo isso funcionando, acaba dando bastante orgulho, porque ele acaba realmente matando diversas dores que a gente tem na hora de a gente desenvolver um software ou fazer, por exemplo, relatórios dessa forma como a gente está trabalhando, beleza? Então, esse aqui é o nosso orquestrador, ele é bem simples, por isso que eu não quis utilizar outras estruturas que acabam sendo um pouquinho mais complexas em uma estrutura que pode ser mais simples nesse caso por conta do orquestrador. Então, por isso que a gente categorizou dessas formas, mas, vamos dizer assim, a grosso modo, a gente consegue adaptar e você não precisa ficar preso exatamente nisso, da forma como eu coloquei. Fechou? Então era isso, galera, que eu queria passar por essas estruturas de prompts. Elas realmente são importantes e eu espero que você esteja aproveitando. Saiba que você vai ter acesso ao repositório com todos esses prompts para você fazer os seus testes, para você melhorar esses prompts, para você ter uma visão mais crítica e inclusive conseguir tirar resultados ainda melhores. Fechou? Um grande abraço e é isso aí.
