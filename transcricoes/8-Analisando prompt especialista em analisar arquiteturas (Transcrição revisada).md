Bom, pessoal, então vamos lá. Nas aulas passadas, eu trouxe aqui para vocês um dos formatos de prompts que são importantes e que a gente já viu. E são prompts especializados, inclusive, para a gente conseguir trazer saídas, conseguir trazer instruções negativas, como que a gente pode tratar erro e etc. Nós fizemos isso com um auditor de dependências. De qualquer forma, o que acontece aqui? Aqui eu tenho um projeto. Dentro desse projeto aqui, eu criei uma pasta chamada Agentes. Aqui eu estou dentro da pasta .cloud, porque especificamente eu estou usando o Cloud Code. Eu não estou dizendo, inclusive, que você é obrigado a ter o Cloud Code para fazer essa aula. Nosso ponto principal aqui não é o Cloud Code. Nosso ponto principal aqui está em você entender como que você cria e entende esses prompts, porque eventualmente você vai conseguir aplicar isso em qualquer outra ferramenta de IA que você for utilizar. Nesse caso, eu estou utilizando o Cloud Code, mas somente para deixar claro que não tem nenhuma obrigatoriedade para que você tenha que ter o Cloud Code para entender o que eu vou ensinar. Talvez você não consiga executar exatamente como o Cloud Code faz em outra ferramenta. Ferramentas têm comportamentos diferentes, mas é importante que você entenda os prompts e a ideia principal. Então, eu criei algumas pastas aqui. Nesse caso, a gente está numa parte mais exploratória, então é somente para uma organização minha aqui. E um agente especializado que eu quero trazer aqui apenas para a gente fazer mais um review dessa mesma estrutura de prompt, é esse Architecture Analyzer. Esse agente aqui, especificamente, criado pelo Cloud Code, ele tem alguns pontos extremamente interessantes e que vale a pena você entender. Primeira coisa que eu já quero deixar claro aqui para você é o seguinte, nós estamos falando desse tipo de formato aqui de agente. Essa parte aqui, basicamente, são metadados do Cloud Code. Então, eu não estou levando isso muito em consideração, mas basicamente ele traz aqui para mim qual é o modelo que vai ser utilizado, qual a cor que vai aparecer, exemplos de quando esse agente pode ser trigado, ou seja, quando ele pode ser chamado através do Cloud Code. Mas o nosso ponto principal está aqui, persona, objetivo, inputs, outputs. Eu vou tentar abrir isso aqui como MD para que a gente consiga analisar de uma forma um pouco mais clara aqui para a gente. Então, se você perceber, nesse nosso caso, a nossa persona, ou seja, a persona e o escopo nosso aqui, é o quê? É trazer que, já que o meu objetivo é fazer uma análise arquitetural de uma aplicação, o que eu quero trazer aqui para ele é falar exatamente isso. Você é um arquiteto de software, um cara que consegue analisar software de uma forma com uma expertise bem forte em analisar de código, entender padrões arquiteturais, system design, software engineering, best practice e etc. Por que eu estou falando isso? quanto mais informações nesse tipo do papel que eu acabo colocando internamente, de forma geral, eu já consigo colocar um monte de filtro na IA pra ela já entrar com esse contexto entendendo do que eu tô querendo falar tá, então basicamente isso o escopo, eu tô falando assim ó o seu papel é estritamente em analisar e reportar somente, você não vai modificar nada de um projeto, você não vai refaturar código, você não vai alterar o codebase de forma nenhuma, então aqui eu dei o escopo? No que ele é especialista? Ou seja, a gente consegue trazer um olhar diferente na hora que o Cloud vai rodar ou qualquer IA vai trabalhar, mas eu também estou dando um escopo muito grande, que ele não vai fazer nenhuma alteração no site. A ideia dele é ser um cara que vai fazer a geração de um report. Então, aqui nesse nosso caso, nós temos alguns pontos importantes, porque o meu objetivo aqui é fazer com que a gente consiga analisar a estrutura de um projeto de software. E o nosso grande desafio que a gente tem em fazer isso é porque, muitas vezes, nós temos projetos de softwares que são altamente grandes. Nós temos centenas de milhares de linhas de código. Como que eu consigo fazer, de uma forma cada vez mais otimizada, a leitura de tanto arquivo e, ao mesmo tempo, sem estourar aquela janela de contexto, onde a gente tem um limite. Por exemplo, a do cloud, nesse momento, ela é bem fechada, se não me engano, em torno de 200 mil tokens, então não é muita coisa, tá? Então, uma das formas que você tem para conseguir fazer isso é trazer objetivos bem claros do que ele tem que fazer, porque uma vez que ele entende esses objetivos, a forma de como que ele vai ler o codebase vai depender, tá? Então, isso aí é importante, porque não necessariamente eu preciso falar para ele ler 100% do meu codebase. Nenhum desenvolvedor nesse mundo precisa ler 100 do codebase para entender pontos arquiteturais de um software Ent isso a um ponto interessante Por outro lado existem algumas a que eu estou pedindo aqui como objetivos que vai sim fazer com que ele leia o Codebase Mas, de forma geral, quando eu consigo trazer esse objetivo mais claro aqui para ele, fica mais fácil ele entender quais ferramentas e qual estratégia que ele vai usar para ele mesmo internamente de como fazer essa leitura desse Codebase. Principalmente por quê? Porque cada agente de IA tem as suas próprias ferramentas. E, por exemplo, o Gemini tem suas ferramentas de conseguir entender e ler um codebase da mesma forma que o Cloud tem as ferramentas dele e etc. Então, o que vai acontecer é que cada um tem a sua manha. E eu não quero também especificar de uma forma tão forte para fazer com que a ferramenta dele se comporte da forma que eu quero. porque eu não quero isso. Eu quero que ele use as ferramentas da melhor forma que ele tem. Então, o que eu estou fazendo aqui é trazendo um objetivo claro. Então, eu estou falando, faça um mapeamento da arquitetura dos sistemas e dos componentes dessas relações. Então, para você fazer um mapeamento completo do sistema da arquitetura, não necessariamente eu preciso entender 100% dos arquivos. Mas, sim, necessariamente, na hora que eu bato o olho no sistema, eu consigo entender a relação entre um componente e o outro, eu consigo inferir essas informações, e é muito bom para fazer isso. E baseado nisso, ele consegue entender os componentes mais críticos, os principais módulos e o acoplamento onde ele consegue perceber onde tem uma coisa muito acoplada na outra. A nossa ideia aqui também é fazer com que ele faça uma espécie de análise de acoplamento, uma análise aferente, ou seja, todas as dependências que chegam em um determinado componente, e eferente todas as dependências que um componente tem em relação às outras. Isso aqui para a gente é super importante para a gente saber como que uma dependência, como um componente depende do outro ou quantos componentes apontam para o outro. Pedir, obviamente, aqui para ele ter e compreender documentações, pontos de integração com sistemas externos, bancos de dados e etc. verificar os riscos da arquitetura e pontos únicos de falha entender um pouco mais da parte de infraestrutura e padrões de deployment se existirem identificar os principais dívidas técnicas que precisam de atenção e identificar de forma high level riscos de segurança, potenciais vulnerabilidades na arquitetura e trazer essas coisas então se você perceber em nenhum momento aqui eu estou falando que ele leia 100% de tudo. Eu estou trazendo esses pontos e estou trabalhando aqui para que ele consiga usar da melhor forma esse tipo de análise. Eventualmente, dependendo de como for esse tipo de relatório, de como ele trabalhar e você não ficar contente, você pode rodar, por exemplo, esse tipo de prompt em outra ferramenta. Você pode tentar, por exemplo, um GPT-5, você pode tentar o Gemini, e que normalmente tem uma quantidade muito grande de tokens. Os testes que eu fiz até agora, mesmo com sistemas muito grandes, eu consegui ter um resultado bem favorável utilizando o Cloud, mas novamente, isso aqui é apenas um detalhe em relação à parte do LLM. Aqui em relação à parte de inputs, eu já estou trazendo aqui para ele o seguinte, o que você tem que ler, o que você tem de entrada para conseguir fazer essa tarefa? Então eu falei, olha, você tem o código de fonte de todos os diretórios, subdiretórios, você tem que olhar Dockerfile, Docker Compose, arquivos de Kubernetes, arquivos de variáveis de ambiente, arquivos que possam trazer automações como makefiles, gerenciamento de pacotes e independências. Então olha só, às vezes ele não precisa ler 100% dos arquivos para saber que ele está utilizando uma biblioteca X que está em uma versão desatualizada, por exemplo. Esquemas de bancos de dados, migrações, e outras instruções que eu possa passar ali para ele. Então, essa que é a ideia principal. E agora, a gente tem um dos pontos que é o mais importante e que é a parte que acaba ficando muito difícil para nós desenvolvedores quando a gente está fazendo qualquer prompt. E não é só desenvolvedor, qualquer pessoa que vai trabalhar com prompt, que é o output. O output é o que dá mais trabalho sempre. Então, eu estou indo mais a fundo novamente, pode ficar um pouco repetitivo o que eu estou falando, principalmente porque a gente já viu o de auditoria, mas eu queria trabalhar em cima desse cara aqui, somente novamente para reforçar essa parte de output. Então, o output aqui, eu estou falando, sempre retorne um markdown com o nome do report aqui para ele, com as seguintes sessões. E aqui eu estou falando, sumário executivo, a versão high level do System Architecture, a tecnologia, a stack e os principais findings, os principais pontos que ele encontrou de detalhes arquiteturais. Perceba que nesse caso eu deixei isso de uma forma mais genérica, então eu não vou ter tanto controle dessa resposta. Se as respostas e os testes que eu fizer não estiver me satisfazendo nesse sumário executivo, eu posso detalhar exatamente como eu quero. Mas normalmente os testes que eu fiz isso aqui est muito bons em parte de high level mas novamente voc fique na liberdade porque voc vai ter acesso a todos esses prompts tamb System overview, ou seja, eu quero que ele traga a estrutura do projeto, os principais diretórios e os principais patterns identificados. Então fica uma forma mais simples de eu conseguir entender um pouco a árvore do sistema. E agora eu pedi também para ele trazer uma análise crítica de componentes. ou seja, ele vai entender o que pode ser considerado um componente dentro do sistema e vai fazer uma tabela para mim, para eu trazer então tudo que você está vendo aqui e essas tabelas e tudo que eu estou colocando são exemplos porque é aqui que eu estou mapeando como que eu quero o resultado final da coisa nesse caso eu quero um relatório então eu não vou deixar por conta da IA entregar esse relatório da forma que ela quiser eu quero de uma forma estruturada para mim tanto que esse relatório vai ser utilizado como base para outros relatórios. Então, quando eu coloco aqui análise crítica dos componentes, ou seja, eu quero uma tabela com os componentes, sendo que muitos desses componentes podem ser módulos, features, bundles, packages, domínios, subdomínios no projeto. O que isso significa? Porque componente pode ser algo extremamente abstrato. Então, dependendo de como eu separo um projeto, sei lá, eu estou fazendo um projeto em Java, ele tem os pacotes deles com os namespaces deles. Se eu estou fazendo em .NET de uma forma, se eu estou trabalhando com Goa de outra, se eu estou trabalhando com PHP de outra, JavaScript de outra, dependendo da arquitetura, eu posso entender o que é um componente. Então, o que a minha ideia aqui é para que a própria IA, ela tente definir o que ela entende por um componente dentro do software. E para isso, eu trouxe alguns exemplos. Por exemplo, um user service, dependendo, pode ser um componente do tipo de serviço. Um database manager pode ser um componente de infraestrutura. Um billing pode ser um serviço. Um mensagem pode ser um componente de mensageria, como um RabbitMQ. Então, perceba que eu estou aqui dando exemplos do que pode ser um componente. Então, baseado nisso, ele vai entender o software e vai tentar extrair do que ele consegue interpretar do que é um componente. Provavelmente, se ele pegar um software que só tem classes, provavelmente ele vai poder considerar o componente baseado na leitura das classes que ele fez. Então, depende muito da arquitetura, dos layers da sua aplicação, por isso que eu deixei claro que ele pode definir aqui o que ele consegue entender como componente. Então, ele vai buscar se o projeto tem módulos, se o projeto tem algo de pasta de features, se tem bundos, por exemplo, o Symfony, por exemplo, um framework PHP, ele trabalha com bundos. Ou pode ser packages no Go, pode ser domínios, às vezes a pessoa trabalhando com DDD, então ele separa o projeto com pasta de domínios, subdomínios e coisas desse tipo. Então, dessa forma, eu pedi para ele fazer essa evaluação. E aí, eu pedi para ele colocar o nome do arquivo, o principal do componente, e aqui as ligações entre um componente e outro, ou seja, quantos caras estão usando esse componente e quantos caras esse componente está usando. E qual é o principal ponto na arquitetura do software que esse componente acaba fazendo. Então, se você perceber, eu trouxe apenas uma listagem bem simples dos componentes. Eu não estou sendo ultra específicos sobre cada um desses componentes. Também aqui eu estou pedindo para ele trazer um dependency mapping, ou seja, eu estou falando, olha, dependências de alto nível, controller, chama o service, chama o repositório, chama o banco de dados, um controller pode chamar uma API externa, um serviço pode chamar uma message queue. Pontos de integração, quando que eu falo com sistemas externos, Quando que eu tenho componentes que podem ser um ponto único de falha que vai fazer com que o meu projeto inteiro pare? E também pedir para ele fazer uma análise das tecnologias e stacks que eu estou utilizando. Também pedir para ele trazer pontos críticos de segurança que ele conseguiu ver. Também pedir para ele analisar como que o projeto hoje, se tiver, a parte de infraestrutura. E se você perceber, olha aqui que interessante. eu estou colocando only if our files documentation present, otherwise do not include this section. Ou seja, só vai ter essa seção se ele encontrar arquivos referentes a essa parte. Senão, essa seção nem vai existir. E eu pedi aqui claramente para ele salvar o report depois que ele fizer tudo com o seguinte nome, architecture report, e aqui eu pedi para ele colocar como se fosse data, uma espécie de um timestamp aqui, data o dia, mês, ano, hora, minuto e segundo aqui, dentro da pasta específica desse agente que eu determinei, que é barra docs, barra agents. Lembrando que se eu quiser depois mudar essa pasta, eu posso passar uma instrução para IA, substituir essa minha instrução. E depois, fizer isso, eu vou informar quem? O meu orquestrador ou o agente principal, aí vai depender de como que a ULLM quer trabalhar, falando que esse report foi salvo. Então, não inclua esse step no relatório. Eu não quero que no relatório apareça escrito final step. Basicamente é isso. E aqui eu tenho os meus critérios. E olha só que interessante, pessoal. Novamente, critérios de qualidade. Então, a gente viu o output de saída, critérios de qualidade agora. Olha passe por todos os diret para entender a estrutura identifique os principais padr foque no que significante para os componentes da arquitetura, ao invés de olhar todo o arquivo tente calcular as métricas mais críticas dos componentes aferentes e eferentes foi o que eu pedi inclusive lá em cima tente mapear o fluxo de dados, identifique a infraestrutura, verifique os, vamos dizer assim, os limites de cada componente e as integrações. Veja a parte de escalabilidade e potencial a bottlenecks, pontos que podem ser furos em relação a isso. Entenda quais são antipatterns e débitos técnicos que eu tenho aqui. Priorize os componentes pela arquitetura e importância no impacto do negócio. Analise e configuração, o gerenciamento de configurações. Também a parte de documentar esses limites para que ele consiga entender esses patterns. Outra coisa, identificar o que são bibliotecas compartilhadas. Sempre traga o caminho relativo quando eu for referenciar qualquer coisa, para que ele não pegue a minha pasta home da minha máquina inteira. apesar que às vezes mesmo assim ele pega, galera. E antes de apresentar os acoplamentos aferentes e inferentes, introduza esses termos e como que eles funcionam isso em um parágrafo. E a gente vai ver que ele explica o que é um componente aferente e eferente ali no relatório. E aqui eu estou trazendo novamente ambiguidades e assumptions, ou seja, o pressupostos. Se encontrar múltiplos padrões que estão presentes, documente cada um separado. Se tiver arquivos faltando de ministra a estrutura, bote isso como limitação. Então, se você entender, eu estou trazendo diversos pontos que eu quero pensar para evitar ambiguidade caso alguma coisa aconteça. E aqui, instruções negativas. Nunca modifique os arquivos, não traga sugestões, não crie, modifique, não faça diagramas, não assuma nenhum padrão se você não tiver evidência não traga detalhamentos de otimização e sugestão de performance não inclui tempo que ele vai demorar porque muitas vezes gera um plano e fala na primeira semana você vai melhorar isso na segunda semana você vai ter uma tarefa de duas horas às vezes ela faz essas coisas eu não quero estilização, emojis nos meus reports eu não quero que ela crie e alucine fabricações de informação Ou seja, traga as informações mais possíveis. Se você não tem nada, fala que você não tem. Você não tem essa informação. Não dê recomendações, sugestões de improvement. Aqui é um relatório, é um snapshot. Eu não estou tendo um consultor aqui na minha vida. Eu só estou falando o que eu quero. Se ele não conseguir performar essa análise, eu quero que ele traga isso aqui como resultado. E aqui, galera, é um ponto importante. que é como se fosse um reforço de tudo o que aconteceu. Então, apesar de ele entender tudo isso, eu coloquei um workflow aqui passo a passo, para que ele consiga seguir. E se você perceber, esse workflow no final do dia, ele apenas é quase que um resumo de cada item do relatório que eu estou precisando. Então, isso aqui ajuda muito a IA, porque agora que ela entendeu o que a gente quer, eu estou falando como que ela deve trabalhar. Basicamente é isso. Eu estou colocando. Então, aqui é como se fosse um resumo de tudo que ela tem que trabalhar. Inclusive, eu dou detalhes aqui. Se o usuário der o caminho e o nome do arquivo, gere o report baseado no que ele colocou, sem precisar pedir uma confirmação para o usuário. Então, se você olhar aqui, galera, é um prompt, tá? Obviamente, dá trabalho para escrever. Eu tenho que dizer que eu rodei esse cara várias vezes para ficar da forma como eu queria. E, obviamente, ainda, eu poderia adicionar muitas outras partes, muitos outros detalhes nesse componente, mas eu acredito que aqui é um bom ponto de partida, inclusive para você rodar esse prompt no sistema da sua empresa, de alguma forma, obviamente, sempre entendendo a parte de privacidade, estando ligado com as regras, as políticas da empresa, para você não colocar dados sensíveis da sua empresa em inteligências artificiais que não sejam homologadas. Então, quero deixar isso bem claro para você pensar também nos riscos e para você seguir as regras da empresa que você está trabalhando também. Então, isso aqui, galera, novamente, é um prompt que traz resultados específicos. Esse cara é um especialista realmente em analisar arquiteturas de aplicações e eu tentei trazer uma abordagem para fazer com que ele não tenha que ler todos os arquivos porque isso é uma visão um pouco mais de alto nível, tá bom? E conforme a gente for andando, eu vou trazer mais alguns exemplos aqui para vocês de caras especialistas e depois a gente vai para orquestrador e a parte de comando também. Então vamos nessa.
