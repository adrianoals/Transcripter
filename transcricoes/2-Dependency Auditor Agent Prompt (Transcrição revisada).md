Bom pessoal, como eu falei para vocês no vídeo anterior, vamos agora, vamos dizer assim, colocar um pouco mais a mão na massa e entender esse tipo de estrutura e um prompt mais vida real que você pode sair inclusive utilizando, tá? Então eu vou fazer isso aqui, deixar eu aqui no meu Notion, onde eu tenho esse meu prompt e você vai conseguir inclusive ter acesso a isso aqui que eu criei, tá? Então, seguinte, a nossa ideia aqui é nós termos um agente que faz auditoria de dependências em um projeto. Esse prompt aqui, ele está escrito em inglês, mas de forma geral você vai perceber que nós temos exatamente a estrutura que eu passei para vocês. Então, o que a gente está colocando aqui para que a gente consiga entender em relação a essa estrutura? Primeiro passo, persona e escopo, ou seja, a especialidade que o agente tem, quem é esse agente e no final das contas o escopo, ou seja, até onde ele vai, então qual que é a ideia principal. Então, nesse nosso caso aqui, eu estou falando que ele é um senior software engineer e também esse expert em gerenciamento de dependências, com uma expertise gigante em analisar projetos de software e dependências entre múltiplas linguagens de programação. Agora, o ponto importante que eu estou colocando aqui é, o seu papel é estritamente analisar e fazer um report. Você nunca deve modificar nenhum projeto, ou fazer, inclusive, upgrades ou propostas de upgrades, ou alterar o meu codebase em nenhuma etapa. Então, aqui a gente já passa pela nossa primeira estrutura que a gente acabou falando. Segundo ponto aqui, muito claro, e perceba, pessoal, eu sempre tento ser o mais pontual possível para evitar qualquer tipo de alucinação ou evitar com que a IA tente fazer mais ou menos do que eu pedi. Isso é garantido? Não é garantido. Mas você vai perceber que conforme você testa esses tipos de prompt, você vai perceber que você minimiza bastante esses riscos. Então, qual que é o objetivo dele aqui? Bem claro. Performar, fazer uma auditoria completa de dependências que identifique dependências depreciadas, desatualizadas, bibliotecas que estão em formato de legacy, ou seja, que vão ser descontinuadas, verificar, inclusive, vulnerabilidades no banco de dados de vulnerabilidades conhecido, fazer uma flag de bibliotecas que não estão mais sendo mantidas por mais de um ano, eu coloquei aqui, fazer a verificação das compatibilidades de licenças e riscos legais que eu possa ter, e também aqui fazer um highlight de pontos de falha para manutenção que pode causar um grande problema no projeto, e também prover uma forma estruturada de recomendações sem ter que fazer nenhuma modificação no código. Então, se você perceber aqui, eu estou trazendo qual é o objetivo muito claro aqui do agente. então somente de ler isso até para mim fica mais claro o que eu estou querendo e uma dica que eu já dou aqui para você é o seguinte, fazer esses bullet points que eu acabei de colocar aqui para você, não é fácil por que eu estou dizendo isso? porque normalmente a gente quer pedir as coisas para IA, mas a gente mesmo não tem uma clareza tão grande então o grande problema muitas vezes, dificuldade que a gente tem em construir um prompt, um bom prompt é ter essa clareza. Então, por isso, criar prompts que realmente funcionem também dá trabalho por conta disso. Agora, vamos falar sobre inputs. Lembra que a gente tem entrada e saída e tudo mais? Então, a input aqui é o seguinte. A gente vai passar para ele, no final das contas, arquivos de dependências e arquivos lock, onde tem aquela lista realmente das dependências, como package.json, package.lock, pnp, yarn, requirements.txt, estou passando coisas do Rust aqui, do Go e etc. Então, se você perceber aqui, as inputs podem ser os arquivos de dependência, porque para mim são importantes, porque normalmente projetos têm a lista de dependência nesses arquivos. Outra coisa como input é detectar, nesse caso aqui, a linguagem, framework e as ferramentas do repositório. O que mais que ele tem de input? Instruções opcionais do usuário, como focar em segurança, licenciamento, especificação e ecossistema. E se nenhum arquivo de dependência for detectado, falar explicitamente e pedir explicitamente qual é o caminho para confirmar se ele deve proceder ou não com informações limitadas. Então, se você perceber aqui nesse meu input, a minha input, no final das contas, são os arquivos do meu projeto. Mas eu quis detalhar um pouco mais para quê? Para que ele tenha um foco maior nos arquivos que fazem, que tem normalmente o manifesto das nossas dependências ali de forma geral. muitas vezes o usuário na input ele vai querer passar esse prompt mas às vezes pedir algo adicional então por isso que eu tenho uma parte que é opcional ali em relação baseado às instruções do usuário e tamb se eu n passar informa suficiente ele pode ter a liberdade de perguntar para mim e ver se o suficiente para ele conseguir fazer essa auditoria Agora o ponto aqui est nessa parte de output format Então, aqui é uma outra coisa que é muito complexo, novamente, se você não tem clareza do que você quer. Então, nesse caso aqui, eu estou dando aqui para ele como output o seguinte. retorne um markdown, um report de markdown, nomeado como Dependence Audit Report, com as seguintes sessões. E agora que a coisa traz para a gente uma clareza, por exemplo, de um Tree of Thoughts, que no final das contas eu estou especificando exatamente um esqueleto, Tree of Thoughts, não, Skeleton of Thoughts, um esqueleto claro do que eu quero e como eu quero. Então, summary, o sumário, ou seja, dar uma visão de high level do projeto, as dependências e os principais achados, vamos dizer assim. Trazer também, em segundo ponto, critical issues, ou seja, vulnerabilidade de segurança, bibliotecas depreciadas, legacy e dependências core do sistema. Trazer a lista de uma tabela de dependências para a gente com as versões atuais e os status. Por exemplo, o Express na versão tal, a última versão é tal, então falar que ele está outdated. A Lodash, mesma coisa, a Langchain e etc. Então, se você perceber aqui o que eu estou querendo trazer para ele é, nesse caso, um exemplo. Porque se eu falo, traga uma tabela de dependências e mostrar o que está depreciado ou não, fica muito mais difícil e muito mais ambíguo para que a Yala consiga entender. Então, nesse nosso caso aqui, o que a gente está fazendo? Eu estou trazendo especificamente como eu quero. Mesma coisa, análise de risco. Traga os riscos presentes nessa estrutura. Então, eu estou colocando aqui o nível de criticidade, a dependência que eu estou dizendo, a issue que está registrada no banco de dados e os detalhes do que se trata esse tipo de problema. Ou um outro tipo de nível de risco é nível alto, por exemplo, mangúzio e depreciado. Então aqui estou trazendo exemplos aqui para a gente. Uma outra coisa que pode acontecer é que, caso ele não consiga verificar problemas de dependências, a gente pode colocar uma seção aqui para a gente saber o que ele não conseguiu identificar. Porque daí eu posso buscar uma forma minha de tentar identificar esses casos. Então eu estou colocando aqui uma tabela de dependências que não foi possível verificar completamente, como versão, status ou vulnerabilidade. E aí que está o ponto. Eu coloquei aqui, importante, somente inclua essa seção se existirem dependências sem ser verificadas. Por que eu estou dizendo isso? Porque se eu não coloco uma observação dessa, provavelmente ele vai trazer essa seção escrevendo. Nenhuma dependência não foi conseguida fazer a verificação. Ou seja, então eu estou falando, só coloque isso aí caso ele encontre uma dependência. Beleza? Outro ponto agora aqui, e aí vai mais algumas coisas interessantes. Critical file analysis. Então eu estou colocando assim para ele. identifique e analise os 10 arquivos mais críticos do projeto que tenham riscos de dependências ou ele pode ser depreciado, com vulnerabilidade ou muito antigo, ou qualquer coisa desse tipo e eu coloquei, explique o porquê esse arquivo é crítico qual que é o impacto no negócio, na integração do sistema na dependência, na concentração dessa dependência e eu coloquei aqui também para ele porque às vezes você pode ter um comportamento ambíguo. Isso tinha acontecido quando eu fui testar esse prompt. Eu coloquei agora, always use the relative path to identify the files, porque às vezes ele pegava o caminho completo do meu computador e eu não quero que isso fale. Aconteça, então eu falei para ele usar o meu caminho relativo. Perceba que quanto mais detalhe, melhor. Passo número 7, notas de integração. Fazer um resumo de como cada dependência é usada no projeto. um plano de ação, criar recomendações para os próximos passos sem mostrar os esforços ou o tempo estimado por que eu estou colocando dessa forma? grande parte das inteligências artificiais, quando eu peço para ele fazer um report, uma lista de tarefa ou qualquer coisa desse tipo eles tem uma mania de colocar o seguinte, olha, para resolver esse problema é um dia, ou para resolver esse problema, quatro horas de trabalho, meu, eu não quero nada disso, não tem sentido nenhum ainda mais se eu for resolver esse problema com o IA então eu não sei da onde que ele tira esse tempo, e se eu realmente quisesse colocar esse tempo eu teria que colocar no meu prompt como que ele pode fazer o cálculo desse tempo, nesse caso eu estou explicitando para que ele não coloque esse tipo de coisa e depois o final step é depois de você produzir o report completo o relatório completo, se o usuário não colocou qual é o arquivo e o caminho desse arquivo, eu quero que ele explicitamente pergunte, você quer salvar esse report em algum lugar? Se voc quiser traga aqui para mim o nome o caminho e o nome do arquivo Por qu Porque muitas vezes dependendo da intelig artificial que voc vai usar ele vai gerar esse report na tela Por exemplo se voc tiver com o Cloud Code o Gemini ou alguma coisa desse tipo no CLI, ele vai trazer mais ou menos esse report no seu CLI, e às vezes é muito ruim de ver, e normalmente esse report eu vou querer salvar comigo para eu mostrar para alguém ou para eu tomar alguma decisão. Então, se eu, no momento que eu chamei esse agente, ou utilizei esse prompt, eu não informar qual arquivo que é para ele gerar esse report, eu quero que ele me pergunte. E agora, a gente tem os pontos aqui de critérios. Somente para você lembrar aonde que a gente está. A gente está no output. Se você olhar aqui no nosso documento inicial, a gente tem output, critérios, ambiguidade, instruções negativas, tratamentos de erro. Então, perceba que o nosso prompt, apesar de eu estar falando já faz um tempo aqui a gente ainda está na parte de output então uma vez que acabou essa parte de output a gente vai para critérios e esses critérios aqui são importantes para caramba para conseguir fazer com que esse relatório ele seja gerado de acordo com o que eu estou esperando então quais são os critérios que ele tem que pensar aqui Identificar todos os package managers e os arquivos de dependência. Porque se ele não fizer isso, no final das contas, fica mais difícil. Catalogar as dependências diretas somente. Ou seja, nesse momento, ignorar as dependências transitivas. O que isso significa? Quando você tem uma dependência que depende de outra dependência que depende de outra dependência. Então, quando isso acontecer, eu estou pedindo para ele ignorar. Porque senão a gente vai entrar numa árvore gigante de dependências, Não que isso não seja importante, é, mas nesse report eu só quero saber minhas dependências diretas. E daí eu coloquei aqui, compare cada dependência contra a última versão estável dessa dependência apenas para reportar. Por que normalmente eu estou reforçando dessa forma para garantir que ele não vai nem tentar fazer um upgrade? Faça um flag de dependências que estão depreciadas. considere pacotes que não estão sendo mantidos por mais de um ano verifique as vulnerabilidades que estão no banco de dados de vulnerabilidades verifique a licença categorize os riscos por critical, high, medium e low eu imagino que você deva ter visto naquela tabela e talvez tenha pensado opa, mas ele não especificou quais são os tipos de criticidade então aqui eu estou colocando os critérios para na hora que ele gerar a tabela, eu escolher como ele está querendo trabalhar. Outra coisa, identifique os pontos de falha, os single points of failures, ou seja, dependências que geram impacto em múltiplas features do meu software. Coloquei aqui, faça um highlight e breaking changes que foram introduzidas nessas novas versões. Verifique a manutenção e o esforço de manutenção para manter essas dependências atualizadas. Quando estiver disponível, utilize MCP servers como um Context 7 ou um Firecrawl para validar as versões, as manutenções e as vulnerabilidades. Por quê? Porque esses MCPs têm acesso a documentações, como o Context 7, e o Firecrawl, no final das contas, ele consegue fazer ali uma varredura, uma leitura das páginas de uma forma muito mais completa do que alguns outros caras que fazem web scrape, no final das contas. Mas você não é obrigado a usar o Firecrawl, e somente se, por exemplo, o seu MCP estiver ativo. Mas perceba, eu estou falando para ele usar MCP Servers, e eu dei exemplos de MCP servers, mas eu não estou falando necessariamente quais ele tem que usar. Por quê? Eu posso ter algum outro MCP server que possa fazer a mesma coisa que um Contact 7 da vida ou um Firecrawl aqui para a gente. Outra coisa, sempre traga para mim o número das versões, as identificações aqui de banco de dados e também uma versão aqui completa dos próximos passos. focando sempre em sites mais claros do que você dar conselhos mais genéricos. E se você não conseguir acessar pacotes externos, registros, MCP servers, bancos de dados e vulnerabilidades, mostre claramente essa limitação e trabalhe apenas com a informação que você tem nos arquivos de projeto. Então, eu quero que isso fique muito claro mas que ele mostre para a gente que ele tem essa limitação. Então, aqui a gente está na parte de critérios. Então, são critérios que eu quero que ele use para ele conseguir gerar o report naquele formato que é o output que a gente passou. E aqui a gente tem ambiguidades e pressupostos, assumptions. Então, eu vou dar um exemplo aqui para que ele parta do princípio para evitar confusões. Então, por exemplo, se eu encontrar múltiplos ecossistemas que estão presentes, faça o audit dele separado e fale isso explicitamente no resumo. Como assim? Imagina que eu estou em um projeto que está trabalhando com Python e um outro projeto que está trabalhando com Go e eles estão na mesma pasta onde eu estou rodando o agente. Ent ele tem que perceber que ele est em projetos diferentes ou eventualmente um projeto back ou um projeto front Outra coisa se tiver registros externos bancos de dados ali onde você pode, por exemplo, encontrar vulnerabilidades. Ah, e toda hora eu estou falando de banco de dados de vulnerabilidade, estou falando de CVE, somente para você saber e deixar claro, para evitar dar mais clareza para vocês. CVE significa Common Vulnerability Exposures. Então, basicamente, são exposições de vulnerabilidades que são conhecidas e cada uma dessas vulnerabilidades vem com um tipo de um código, onde vai falando qual é a vulnerabilidade, o código permite que a empresa e as ferramentas de segurança fiquem sabendo e utilizem um ID único para cada vulnerabilidade, somente para deixar claro aqui para vocês. Outra coisa, se alguma versão estiver faltando aqui, documente e coloque ali o seu nível de confiança em relação a isso. Se estiver faltando lockfiles, ou seja, aquele arquivo que trava a versão que você está trabalhando no projeto, fale que você não tem, que o seu risco é maior para você reproduzir isso quando for para a produção. Aqui, se o usuário não especificar a pasta que ele quer auditar, faça o audit no projeto inteiro. Se não, faça somente na pasta que ele pediu. E por que eu estou dizendo isso? Porque às vezes eu tenho várias pastas no meu projeto e eu quero validar somente um projeto, às vezes eu estou num monorepo, às vezes eu quero auditar uma feature ou alguma coisa desse tipo. E agora a gente entra naquela outra parte, que é instruções negativas. Então aqui, não modifique ou sugira edição no codebase. Não rode nenhum comando de upgrade. Não crie nenhum CVI ou assuma vulnerabilidades. vai que a IA alucina e ela inventa um código como se isso fosse uma vulnerabilidade comum. Não use frases vagas como provavelmente seguro ou isso aqui deve estar ok. Não use emojis ou caracteres estilizados. Galera, se tem algo que me irrita particularmente é a utilização de emojis em relatórios e coisas desse tipo. Então eu sempre tento forçar para que ela não utilize. E eu vou ser honesto com você, que às vezes, mesmo assim, a IA acaba colocando, mas eu tento minimizar para caramba isso. Outra coisa, novamente, instruções negativas, e vale sempre apenas reforçar, não dê estimativa de tempo para resolver, como dias, horas, duração, ou em tantas horas, para fazer a resolução de fix e upgrade, para correção e fazer upgrade. Agora aqui a gente tem a parte de erro. E a parte de erro aqui eu estou colocando. Se ele não conseguir fazer auditoria, como não encontrou arquivos de dependência ou não conseguiu acessar os arquivos ou qualquer coisa desse tipo, responda no seguinte formato. Status erro, razão. Nenhum arquivo de dependência encontrado. Dê uma instrução clara aonde e porquê isso aqui não foi performado. Isso gira também próximos passos. Por exemplo, dê o caminho onde estão as dependências, os arquivos de manifesto. Dê permissão à Workspace para ele poder ter leitura desses arquivos. Confirme qual ecossistema você está utilizando ou está querendo auditar. Então, aqui são formas que ele pode trazer de erro caso ele não consiga realmente fazer a tarefa. A não ser que, provavelmente, esses tipos de erro podem acontecer se você tiver alguma falha de, como se diz, permissão que a IA vai ter para ler os seus arquivos ou alguma coisa desse tipo. E aqui, por último, pessoal, eu gosto às vezes de reforçar quando eu quero ter um passo a passo do que a IA vai fazer. Apesar de eu ter passado passo a passo do que eu coloquei lá em cima, aqui eu estou fazendo um resumo, ou seja, o workflow que ele vai trabalhar. Então, novamente, detectar o projeto, a TechStack, os Package Manager, fazer um inventário das dependências, comparar e declarar as versões, fazer o flag, detectar vulnerabilidades, verificar a compatibilidade de licença, categorizar, identificar os arquivos, performar e etc. Então, basicamente, aqui é o workflow que eu estou dando passo a passo aqui para ele. Quando eu escrevo o workflow, para ele fica muito mais simples entender esse meu passo a passo de uma forma resumida. Então, normalmente, eu costumo fazer assim e até mesmo para eu ler fica um pouco mais claro. Então, se você perceber, esse é um prompt, não estou dizendo que é o melhor prompt possível e também não quero dizer que esse prompt vai funcionar 100% da melhor forma possível, porque provavelmente os resultados que esse prompt vai trazer usando uma IA num determinado tipo de codebase ou uma IA com outro modelo ou coisas desse tipo, novamente a gente está falando sobre probabilidade. Mas um prompt desse, com certeza, ele já consegue trazer algo um pouco mais estruturado. Eu sei que esse vídeo ficou grande, mas no próximo vídeo eu vou trazer para você como que é o resultado desse prompt que ele trouxe aqui para mim. Então vamos nessa.
