Bom, pessoal, da mesma forma que a gente fez isso para a arquitetura do sistema, eu quero mostrar novamente o mesmo prompt. Galera, isso aqui é uma disciplina de prompt engineering. Eu não posso deixar de falar dos prompts. Eu sei que a gente já entendeu essa estrutura básica, mas eu quero trazer e tentar explicar cada vez mais exemplos que eu puder para que você consiga otimizar o seu tempo e ter até um pouco mais de insights para você fazer os seus próprios agentes, os próprios prompts aqui. Então, somente para você entender, novamente, o cara, a persona e escopo é basicamente a mesma coisa, onde ele faz análise de código. E aqui também, inclusive, lógicas de negócio, extração de lógicas de negócio. Perceba bem o que eu coloquei aqui, extração de lógicas de negócio. Então, o objetivo dele é fazer uma compreensão em nível de componente, porque antes a gente teve uma compreensão em nível de arquitetura geral do sistema e naquele documento nós tivemos a listagem dos componentes do sistema. Então, a nossa ideia aqui é que esse prompt pegue cada componente que existe listado naquele relatório de arquitetura e gera um relatório específico para cada componente. Então, aqui o que eu estou pedindo? Mapear completamente a estrutura e a organização desses componentes. Extrair os documentos e todas as regras de negócio, lógicas de validação, use cases e regras de domínio. Analisar implementações, algoritmos e data flow, ou seja, o fluxo de dados daquele componente. Identificar as dependências internas e externas e as integrações, documentar e entender os design patterns, as decisões arquiteturais e os atributos de qualidade. Isso aqui, no final das contas, é o que define, inclusive, o que é a arquitetura. E entender o acoplamento de cada componente a coes e os seus limites arquiteturais entender pontos de seguran como que ele est vendo erros padrões de resiliência, identificar dívidas técnicas e codes MELS aqui para a gente. Então, esse é o objetivo principal. Se você perceber, agora eu estou sendo um pouco mais detalhista em relação ao que ele vai ler na quantidade de arquivos. provavelmente ele vai como eu estou analisando especificamente um componente apenas eu posso ser mais preciso e falar para ele ser um pouco mais agressivo na leitura dos arquivos que estão dentro desse componente, porque com certeza são menos arquivos do que tem no projeto como um todo, como a gente fez na arquitetura mas novamente depende do nível que você quer olhar por exemplo, se você tem na sua empresa um componente muito grande, provavelmente você poderia rodar um outro prompt ou uma outra chamada para ele gerar subcomponentes para você ter um relatório mais preciso do que isso acontece, então você pode ir do alto nível e baixando o nível, e cada nível que você vai baixando você pode ter um prompt diferente tudo isso vai depender do tamanho do projeto, novamente não tem uma regra geral que vai funcionar para todo mundo então provavelmente esse prompt que eu estou utilizando aqui para você, dependendo da situação, não pode trazer tanta informação da forma como você queria ou às vezes pode trazer até mais informação do que você gostaria. Por isso que é importante você ter autonomia para você conseguir trabalhar nos seus prompts e não ficar dependendo, obviamente, somente dos prompts que eu trago aqui no curso para você. Legal? E aqui são os inputs. O input é o componente, os serviços, os diretórios onde estão identificados no report de arquitetura, porque lá tem os caminhos, os arquivos e as implementações, as interfaces, os testes, as documentações, os arquivos de configuração, os arquivos de testes, desde fixtures, desde mocs, dependências, declarações, os imports. E opcional, ele pode olhar o arquivo de arquitetura e ver quais são os componentes mais críticos para entender um pouco melhor e outras an que o usu pode trazer Outros pontos Output novamente aquela parte que d trabalho Ent sumar executivo a DataFlow ou seja como que esse componente funciona em relação a passo a passo. Então, recebi uma solicitação num controller, foi para uma validação, caiu na regra de negócios da parte de processamento, chamou o Stripe, depois persistiu no banco de dados, mandou uma mensagem e retornou ali para um response builder, por exemplo. Entendeu? Então, a ideia é somente para a gente ter uma ideia de como que o fluxo de dados acontece dentro daquele componente. Outra coisa que eu pedi aqui para ele é para ele extrair as regras de negócio de forma quebrada para cada regra de negócio que ele encontrar no sistema. Por que isso é importante? Porque, às vezes, quando eu vou ver um componente, cada componente tem sua regra de negócio. E um componente pode ter diversas regras de negócio. Então, para eu fazer análise e entender um pouco melhor a aplicação que eu estou analisando, provavelmente ter uma ideia de um resumo básico das regras de negócio que aquele componente faz acaba sendo relevante, pelo menos na minha opinião. Aí vai depender de cada um. Então, a minha ideia aqui foi o overview das regras de negócio. Então, basicamente o que eu trouxe, eu criei uma tabelinha em markdown falando qual o tipo de regra, por exemplo, uma validação, qual que é uma descrição dessa regra, Por exemplo, o pagamento mínimo tem que ser de um dólar e aonde está esse arquivo e a linha dessa regra de negócio. E eu fiz isso. E depois disso, eu pedi, inclusive, para ele gerar aqui para mim um detalhamento de cada regra de negócio. Então, eu coloquei regra de negócio, o nome da regra, uma visão geral da regra de negócio, a descrição mais detalhada dessa regra de negócio e pedi para ele trazer um workflow básico de como que funciona essa regra de negócio. Então perceba, galera, que eu estou usando aqui XML ou uma forma como se fosse um placeholder para ele entender que aqui é onde ele vai escrever, porque eu estou colocando uma definição em Markdown aqui para ele, então ele pode confundir. Então eu tento deixar isso da forma mais clara possível ali para a gente. E na descri eu estou falando olha use pelo menos tr par traga o m de detalhes poss de uma forma f de entender como que as regras de neg funcionam para cada componente E aqui eu pedi para ele trazer também a estrutura de componentes, análise de dependências, parecido como a gente fez, mas agora de mais baixo nível, componentes aferentes e referentes, como eu tinha falado, os endpoints, caso exista endpoints. Nem todo componente tem endpoint, mas se esse componente tiver um endpoint, ele vai trazer. e eu falei que um endpoint pode ser considerado, por exemplo, um REST, um GraphQL, pode ser um GRPC. E se esse componente não expor nenhum endpoint, não incluir essa seção. E eu coloquei aqui uma regra mais específica. Se o componente for REST, use o formato abaixo. E daí eu coloquei endpoint, o método e a descrição ali para a gente. Depois, pedir para ele trazer pontos de integração, os patterns estão sendo utilizados, os riscos técnicos, análise de cobertura de testes. pedi para ele salvar o report e fiz o final step e trouxe novamente outros critérios que eu acabo entendendo que são importantes para ele decidir e trabalhar ali para a gente. Também análise de ambiguidades, instruções negativas, como ele trabalha com o erro. E novamente aqui, galera, olha só, o workflow, que é como se fosse um resumo de tudo que eu coloquei lá em cima para que a IA possa seguir esse passo a passo. Então, esse workflow é um resumo, ele é interessante muitas vezes quando você tem muita informação e muita instrução. Eu gosto de colocar esse workflow. Se você olhar aqui no formato de prompts, eu não estou colocando aqui o workflow, mas eu vou até adicionar e eu vou deixar como opcional o workflow. Opcional, porque vai depender do tipo de tarefa que você vai fazer. Se ela é muito complexa, se ela é muito longa ou coisas desse tipo, você pode colocar um workflow ou não. então galera, isso aqui foi mais um exemplo de como eu utilizei esse tipo de prompt para ele fazer uma análise interna de componentes de uma aplicação daqui para frente a gente vai ver outros tipos de componentes que vão ser importantes para a gente também
