Bom, pessoal, no vídeo anterior, a gente ficou explicando e falando sobre o prompt e aquela estrutura que a gente seguiu. Agora, o negócio aqui é o seguinte. Aqui é um exemplo de um resultado de quando eu rodei esse prompt dentro de um codebase que eu tinha aqui comigo. Somente a gente vai olhar isso aqui, somente para você ter uma ideia de como ele gerou. Mas depois, em seguida, o que eu vou fazer? Eu vou mostrar para você um prompt bem pequeno de um comando do Cloud Code. E lembrando, pessoal, talvez na hora que você esteja vendo esse vídeo, o Cloud Code tenha mudado o formato de trabalho, ou talvez ele esteja de uma forma diferente ou qualquer coisa desse tipo. Mas a ideia principal aqui não é focar na ferramenta Cloud Code ou no Gemini, ou nas ferramentas do Codex da OpenAI ou qualquer coisa desse tipo. mas sim pensar em como que o prompt pode afetar, beleza? Então, aqui é um resultado daquele report. Você deve também estar se perguntando, Wesley, por que você fez aquele report inteiramente em inglês? Normalmente, a IA tende a trazer resultado um pouco melhor, ou às vezes, dependendo da situação, bem melhor em inglês, porque ela tem mais treinamento em inglês. Por outro lado, eu vou deixar isso bem claro para você, no meu dia a dia, por muitas e muitas vezes, quando eu vou criar um prompt, normalmente eu faço esse prompt em português e na maioria das vezes isso funciona, eu escrevo muito mais rápido, meu português é muito melhor para eu escrever do que o meu inglês e tudo mais. o que eu também faço dependendo de como eu vou distribuir ou caso eu queira emprestar ou dar esse prompt para alguém ou na empresa que essa pessoa trabalha e eles trabalham s com ingl eu simplesmente vou e traduzo usando o pr IA o meu prompt de portugu para ingl e obviamente a voc tem que passar um pente fino para evitar qualquer mal entendido até mesmo nesses tipos de tradução. Então por isso que você está vendo todos esses resultados que a gente colocou em inglês. Uma outra coisa que a gente pode fazer é, no final do prompt, falar para ele gerar o relatório completamente em português. talvez seja uma outra solução aqui também para a gente. A gente pode até testar isso depois. Então, basicamente, eu vou mostrar aqui o report que ele gerou nesse Codebase. Então, ele trouxe aqui dependency audit report, aqui o sumário, ou seja, o resumo. Eu poderia colocar para ele colocar a data que eu gerei aqui também, logo lá nas instruções. E aqui ele está falando que eu tenho um projeto de agentes baseado em Python, criado em cima do Google ADK, que implementa a verificação de bugs e criar issues no GitHub, no formato de uma pipeline. Esse projeto tem 11 dependências diretas, espalhadas num requirements.txt, com no lock files present, ou seja, eu não tenho um arquivo ali locado do requirements.txt. Enquanto as dependências, elas geralmente são bem mantidas, a gente tem algumas vulnerabilidades de segurança e versões que foram identificadas. Então, aqui ele trouxe para mim aqui key findings, ou seja, aqueles encontros, aqueles achados que ele acabou de fazer. Então, ele colocou aqui uma vulnerabilidade crítica de segurança e ele trouxe aqui baseado no Light LLM. Light LLM é um pacote que você usa para você utilizar qualquer modelo de inteligência artificial, independente se você está rodando com ADK, por exemplo. ele achou seis depend cr de vulnerabilidade uma depend que pode estar escrito um problema de type ou seja ela foi escrita de forma errada ou ela n est sendo utilizada no projeto não encontrou nenhum lockfile que pode gerar problemas na hora que eu for colocar em produção, porque os lockfiles são aqueles caras que realmente garantem qual é a versão exata que está sendo utilizada e tudo mais, tipo um package .lock, quando a gente está trabalhando, e versões misturadas de especificações de padrões, algumas pinadas ou não pinadas. Ah, e só para ficar mais claro, o que é pinado e não pinado? Quando eu estou falando que uma, quando eu tenho uma dependência pin, significa que essa dependência tem a versão exata de qual ela está sendo utilizada. Ou seja, se houver alguma nova versão dessas dependências, não é feito o upgrade, porque você tem exatamente a versão, tipo 1.0.2. Mas aqui também eu tenho dependências que eu não tenho isso. Então, só está o nome da dependência. Significa que se em algum momento houver uma atualização, isso vai ser feito e talvez possa quebrar o meu software. Então, isso é importante. E aqui ele trouxe os critical issues do que está acontecendo e principalmente no Lite LLM, que ele tinha falado bastante, achou no Paident, que também, no Pendas, ele trouxe dependências depreciadas, aqui onde ele achou, e ele falou aqui, pode ter um problema de typo ou você tem que verificar o nome do pacote para ver se realmente está certo. Daí ele trouxe aqui a lista de dependências que eu tenho e quais são as dependências que estão desatualizadas e coisas desse tipo. A ele trouxe para mim uma an de risco falando o que pode acontecer com essas depend aqui para mim depend sem ser verificadas ele repetiu aqui por conta daquela que pode estar algum erro e aqui ele come a trazer aqui para mim os arquivos que tem mais criticidade em relação às dependências. Então ele trouxe aqui o agent.py, ou seja, basicamente ele pegou todos os arquivos principais de agentes que estão utilizando pontos do Google ADK, o Python.env, ou seja, ele pegou os arquivos mais críticos que são afetados por essas dependências aqui. E ele fala o porquê, porque eles usam isso como o core do workflow do meu agente, ele usa a informação sensitiva, sensível, porque ele cria uma issue no GitHub, tem acesso ao Discord, ele tem vulnerabilidades de autenticação e configuração, ele também acessa a logs externos que possam conter conteúdos maliciosos. E aí ele traz aqui o integration notes, falando o que eu estou utilizando e os principais pacotes aqui para mim, e o meu plano de ação aqui imediato que eu devo ter para tentar resolver esse meu problema. Ou seja, resolver o nome daquele pacote, fazer o update do Lite LLM, atualizar o Pident, atualizar o Pandas, colocar um lock file, forçar as versões, verificar as minhas variáveis de ambiente, o .env, para evitar. e aqui ele trouxe um monte de coisa aqui para eu fazer. Então, no final das contas, pessoal, esse foi o resultado do relatório que eu consegui baseado naquele prompt que a gente acabou colocando e trabalhando. Próximo vídeo eu vou mostrar isso aqui na prática para vocês e vou mostrar também como que eu fiz para invocar esse relatório, ou seja, esse tipo de dependência aqui para a gente. Beleza? Então, vamos nessa.
